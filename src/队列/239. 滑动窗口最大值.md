## 239. 滑动窗口最大值

> [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

### 输入输出

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

输入：nums = [1], k = 1
输出：[1]
```

### 题解

- 单调栈是一种非常适合处理 **“下一个更大元素问题”** 的数据结构
- 单调队列是一种非常适合处理 **“滑动窗口最大值”** 的数据结构

**我们先用 “空间换时间” 的通用思路梳理一下：**

在暴力解法中，我们每移动一次窗口都需要遍历整个窗口中的所有元素找出 “滑动窗口的最大值”。现在我们不这么做，我们把滑动窗口中的所有元素缓存到某种数据容器中，每次窗口滑动后也向容器增加一个新的元素，而容器的最大值就自然是滑动窗口的最大值

**现在，我们的问题已经发生转变，问题变成了：“如何寻找数据容器中的最大值”。** 另外，根据题目条件限制，这个容器是带有约束的：因为窗口大小是固定的，所以每加入一个新元素后，必然也要剔除一个元素。 **我们的数据容器也要满足这个约束。** 现在，我们把注意力集中在这个容器上，思考一下用什么数据结构、用什么算法可以更高效地解决问题。由于这个容器是我们额外增加的，所以我们有足够的操作空间

- **方法 1 - 暴力：** 遍历整个数据容器中所有元素，单次操作的时间复杂度是 `O(k)O(k)O(k)`，整体时间复杂度是 `O(n⋅k)O(n·k)O(n⋅k)`
- **方法 2 - 二叉堆：** 不需要遍历整个数据容器，可以用大顶堆维护容器的最大值，单次操作的时间复杂度是 `O(lgk)O(lgk)O(lgk)`，整体时间复杂度是 `O(n⋅lgk)O(n·lgk)O(n⋅lgk)`
- **方法 3 - 双端队列：** 我们发现二叉堆中很多中间元素是冗余的，拉低了效率。我们可以在每处理一个元素时，可以先观察容器中刚刚加入的元素，如果刚刚加入的元素小于当前元素，则直接将其丢弃（后进先出逻辑）。最先加入容器的元素，如果超出了滑动窗口的范围，也直接将其丢弃（先进先出逻辑）。所以这个容器数据结构要用双端队列实现。因为每个元素最多只会入队和出队一次，所以整体的计算规模还是与数据规模成正比的，整体时间复杂度是 `O(n)O(n)O(n)`

```js
function maxSlidingWindow(N, nums) {
  const res = []
  const len = nums.length
  const dq = []
  for (let i = 0; i < len; i++) {
    // 若队列不为空，且当前元素大于等于对尾所有下标的元素，则弹出对尾
    while (dq.length && nums[i] >= nums[dq[dq.length - 1]]) {
      dq.pop()
    }
    // 入队当前元素下标
    dq.push(i)
    // 判断当前最大值是否在窗口中，若不在便将其出队
    while (dq[0] <= i - N) {
      dq.shift()
    }
    // 当达到窗口大小时便开始向结果中添加数据
    if (i >= N - 1) {
      res.push(nums[dq[0]])
    }
  }
  return res
}
```

## 相反求最小值

A 公司准备对他下面的 N 个产品评选最差奖，评选的方式是首先对每个产品进行评分，然后根据评分区间计算相邻几个产品中最差的产品。评选的标准是依次找到从当前产品开始前 M 个产品中最差的产品，请给出最差产品的评分序列

```js
输入：
3
12,3,8,6,5
输出：
3,3,5
解释：
12,3,8 最差的是3
3,8,6 中最差的是3
8,6,5 中最差的是5
```

```js
function minSlidingWindows(N, nums) {
  const res = []
  const len = nums.length
  const dq = []
  for (let i = 0; i < len; i++) {
    while (dq.length && nums[dq[dq.length - 1]] >= nums[i]) {
      dq.pop()
    }
    dq.push(i)
    while (dq[0] <= i - N) {
      dq.shift()
    }
    if (i >= N - 1) {
      res.push(nums[dq[0]])
    }
  }
  return res
}
```

